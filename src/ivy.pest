// basic tokenization
char = { ASCII_ALPHANUMERIC | "_" | ":" }
WHITESPACE = _{ " " | "\t" | NEWLINE }
// periods can only be in the middle of identifiers
// (to disambiguate the period in forall T. e)
ident = @{ char+ ~ ("." ~ char+)* }

// the top-level rule
file = {
  SOI ~ "let" ~
  actions ~ "in" ~
  step_block ~
  ("while" ~ "*" ~
  invariants)? ~
  EOI }

invariants = { invariant* }
invariant = { "invariant" ~ "[" ~ ident ~ "]" ~ expr }

actions = { action_def* }
action_def = { ident ~ "=" ~  action }
binders = _{ ident ~ ("," ~ ident)* }
action_binders = { "(" ~ binders ~ ")" }
action = { "action" ~ action_binders? ~ step_block }
step_block_or_step = _{ step_block | step }
step_block = {
  // an empty step block
  "{" ~ "}"
  | "{" ~ step_block_or_step ~
    (";" ~ step_block_or_step)* ~ "}"
}

step = { assign | assume | assert | if_step }

relation = { ident ~
  ( // explicit call to nullary relation
    "(" ~ ")" |
    // some arguments
    "(" ~ binders ~ ")" )? }
assign = { relation ~ ":=" ~ expr }
assume = {  "assume" ~ expr }
assert = {  "assert" ~ expr }
some = { "some" }
if_cond = { some ~ ident ~ "." ~ expr | expr }
if_step = {
  "if" ~ if_cond ~ step_block_or_step ~
  ("else" ~ step_block_or_step)?
}

expr = { prefix* ~ term ~ (infix ~ prefix* ~ term)* }

// the infix/prefix operators
infix = _{ and | or | implies | iff | equal }
and = { "&" }
or = { "|" }
implies = { "->" }
iff = { "<->" }
equal = { "=" }
prefix = _{ not }
not = { "~" }

// remaining expression constructs

quantifier = _{ forall | exists }
forall = { "forall" }
exists = { "exists" }
quantified_expr = { quantifier ~ ident  ~ "." ~ expr }

havoc_expr = { "*" }
base_expr =  _{ quantified_expr | havoc_expr | relation }
term = _{ base_expr | "(" ~ expr ~ ")" }
